
<!DOCTYPE html>
<html lang="fr">
<head>
    <link rel="manifest" href="/site.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards Français-Anglais</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --text-color: #333;
            --card-bg: #fff;
            --card-shadow: rgba(0, 0, 0, 0.1);
            --body-bg: #f5f7fa;
            --translation-color: #2ecc71;
            --subtitle-color: #666;
            --info-color: #666;
            --button-bg: #e0e0e0;
            --button-text: #333;
            --progress-bg: #e0e0e0;
            --incorrect-color: #e74c3c;
            --correct-color: #2ecc71;
        }
        
        body.dark-mode {
            --primary-color: #ffffff;
            --secondary-color: #3498db;
            --text-color: #000000;
            --card-bg: #2c3e50;
            --card-shadow: rgba(0, 0, 0, 0.3);
            --body-bg: #1a1a1a;
            --translation-color: #3498db;
            --subtitle-color: #bbb;
            --info-color: #bbb;
            --button-bg: #34495e;
            --button-text: #fff;
            --progress-bg: #34495e;
            --incorrect-color: #e74c3c;
            --correct-color: #2ecc71;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--body-bg);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        
        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--subtitle-color);
            text-align: center;
            margin-bottom: 30px;
        }
        
        .container {
            width: 100%;
            max-width: 600px;
        }
        
        .chapters {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .chapter-btn {
            padding: 8px 15px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .chapter-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .mode-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .mode-btn {
            padding: 8px 15px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .mode-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background-color: var(--progress-bg);
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary-color);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .card-container {
            height: 300px;
            margin-bottom: 20px;
        }
        
        .card {
            width: 100%;
            height: 100%;
            cursor: pointer;
            box-shadow: 0 10px 25px var(--card-shadow);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--card-bg);
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .card-content {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .english-translation {
            color: var(--translation-color);
            font-size: 2rem;
            font-weight: bold;
            display: none;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .info {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        .timer-container {
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .stats-container {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        .raw-content {
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            width: 100%;
            height: 300px;
            overflow-y: auto;
            display: none;
            white-space: pre-line;
            box-shadow: 0 10px 25px var(--card-shadow);
            text-align: left;
            font-size: 1rem;
            line-height: 1.6;
        }
        
        .validation-container {
            width: 100%;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .input-group {
            display: flex;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .translation-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--button-bg);
            border-radius: 5px 0 0 5px;
            font-size: 1rem;
            background-color: var(--card-bg);
            color: var(--text-color);
        }
        
        .validate-btn {
            padding: 10px 15px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
            font-weight: 600;
        }
        
        .validation-result {
            margin-top: 5px;
            font-weight: bold;
            height: 20px; /* Hauteur fixe pour éviter les sauts de mise en page */
        }
        
        .correct {
            color: var(--correct-color);
        }
        
        .incorrect {
            color: var(--incorrect-color);
        }
        
        .scores-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 10px;
        }
        
        .score-item {
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        @media (max-width: 600px) {
            .card-content {
                font-size: 1.5rem;
            }
            
            .english-translation {
                font-size: 1.2rem;
            }
            
            .btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .translation-input {
                border-radius: 5px;
                margin-bottom: 5px;
            }
            
            .validate-btn {
                border-radius: 5px;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Flash Cards Français-Anglais</h1>
        <p class="subtitle">Traduisez le mot ou cliquez sur la carte pour voir la traduction</p>
        
        <div class="mode-controls">
            <button class="mode-btn" id="theme-toggle">Mode Sombre</button>
            <button class="mode-btn" id="raw-toggle">Mode Raw</button>
        </div>
        
        <div class="chapters">
            <button class="chapter-btn active" data-chapter="1">Democracy</button>
            <button class="chapter-btn" data-chapter="2">Genetics</button>
            <button class="chapter-btn" data-chapter="3">Immigration</button>
            <button class="chapter-btn" data-chapter="4">International tensions</button>
            <button class="chapter-btn" data-chapter="5">Unemployment</button>
        </div>
        
        <div class="timer-container">
            <div id="timer">00:00</div>
        </div>
        
        <div class="progress-container">
            <div class="progress-bar" style="width: 0%"></div>
        </div>
        
        <div class="card-container">
            <div class="card">
                <div class="card-content">
                    <div class="french-word"></div>
                    <div class="english-translation"></div>
                </div>
            </div>
        </div>
        
        <div class="validation-container">
            <div class="input-group">
                <input type="text" class="translation-input" id="translation-input" placeholder="Entrez la traduction en anglais">
                <button class="validate-btn" id="validate-btn">Valider</button>
            </div>
            <div class="validation-result" id="validation-result"></div>
            <div class="scores-container">
                <div class="score-item">Score: <span id="current-score">0</span></div>
                <div class="score-item">Meilleur score: <span id="best-score">0</span></div>
            </div>
        </div>
        
        <div class="raw-content" id="raw-content"></div>
        
        <div class="controls">
            <button class="btn" id="prev-btn">Précédent</button>
            <button class="btn" id="random-btn">Aléatoire</button>
            <button class="btn" id="next-btn">Suivant</button>
        </div>
        
        <div class="info">
            <span id="current-card">0</span>/<span id="total-cards">0</span>
        </div>
        
        <div class="stats-container">
            <div>Meilleur temps: <span id="best-time">-</span></div>
            <div>Cartes vues: <span id="cards-seen">0</span>/<span id="cards-total">0</span></div>
        </div>
    </div>
    
    <script>
        // Structure de données pour les mots par chapitre
        const vocabularyByChapter = {
            1: [
                { french: "monarchie", english: "monarchy" },
                { french: "monarque de droit divin", english: "a monarch by divine right" },
                { french: "prime", english: "a bonus" },
                { french: "avantage (en nature), avantage annexe", english: "a perk, a fringe benefit" },
                { french: "voiture de fonction", english: "a company car" },
                { french: "salaire au rendement", english: "performance-related pay" },
                { french: "être employé par une entreprise", english: "to be on a company's payroll" },
                { french: "vacances", english: "holiday, vacation (US)" },
                { french: "congés payés", english: "paid holiday" },
                { french: "être en vacances", english: "to be on holiday" },
                { french: "jour férié", english: "a bank holiday" },
                { french: "être en congé maladie", english: "to be on sick leave" },
                { french: "âge de la retraite", english: "retirement age" }
            ],
            2: [
                { french: "génétique", english: "genetics" },
                { french: "gène", english: "gene" },
                { french: "ADN", english: "DNA" }
            ],
            3: [
                { french: "immigration", english: "immigration" },
                { french: "émigration", english: "emigration" },
                { french: "immigrant", english: "immigrant" }
            ],
            4: [
                { french: "tension internationale", english: "international tension" },
                { french: "conflit", english: "conflict" },
                { french: "diplomatie", english: "diplomacy" }
            ],
            5: [
                { french: "chômage", english: "unemployment" },
                { french: "chômeur", english: "unemployed person" },
                { french: "indemnité de chômage", english: "unemployment benefit" }
            ]
        };
        
        // Variables d'état
        let currentChapter = 1;
        let currentCardIndex = 0;
        let isTranslationVisible = false;
        let seenCards = new Set(); // Ensemble pour suivre les cartes déjà vues
        let remainingCards = []; // Liste des cartes restantes à montrer en mode aléatoire
        let isTimerActive = true; // Variable pour suivre si le chrono est actif
        let cardHistory = []; // Historique des cartes visitées
        let isDarkMode = false; // Mode sombre désactivé par défaut
        let isRawMode = false; // Mode raw désactivé par défaut
        let currentScore = 0; // Score actuel
        let bestScores = {}; // Meilleurs scores par chapitre
        
        // Stockage des performances pour chaque carte (mémoire des résultats passés)
        let cardPerformance = {};
        
        // Variables pour le chronomètre
        let startTime;
        let timerInterval;
        let bestTimes = {}; // Stockage des meilleurs temps par chapitre
        
        // Éléments DOM
        const chapterButtons = document.querySelectorAll('.chapter-btn');
        const card = document.querySelector('.card');
        const cardContainer = document.querySelector('.card-container');
        const rawContent = document.getElementById('raw-content');
        const frenchWord = document.querySelector('.french-word');
        const englishTranslation = document.querySelector('.english-translation');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const randomBtn = document.getElementById('random-btn');
        const progressBar = document.querySelector('.progress-bar');
        const currentCardElement = document.getElementById('current-card');
        const totalCardsElement = document.getElementById('total-cards');
        const timerElement = document.getElementById('timer');
        const bestTimeElement = document.getElementById('best-time');
        const cardsSeenElement = document.getElementById('cards-seen');
        const cardsTotalElement = document.getElementById('cards-total');
        const themeToggle = document.getElementById('theme-toggle');
        const rawToggle = document.getElementById('raw-toggle');
        const translationInput = document.getElementById('translation-input');
        const validateBtn = document.getElementById('validate-btn');
        const validationResult = document.getElementById('validation-result');
        const currentScoreElement = document.getElementById('current-score');
        const bestScoreElement = document.getElementById('best-score');
        
        // Fonction pour mettre à jour la carte
        function updateCard() {
            const cards = vocabularyByChapter[currentChapter];
            
            if (cards.length > 0) {
                const cardData = cards[currentCardIndex];
                frenchWord.textContent = cardData.french;
                englishTranslation.textContent = cardData.english;
                
                // Ajouter cette carte à l'ensemble des cartes vues
                seenCards.add(currentCardIndex);
                
                // Masquer la traduction anglaise
                englishTranslation.style.display = 'none';
                isTranslationVisible = false;
                
                // Effacer l'input de traduction et le résultat de validation
                translationInput.value = '';
                validationResult.textContent = '';
                validationResult.className = 'validation-result';
                
                // Mettre à jour l'information sur les cartes
                currentCardElement.textContent = currentCardIndex + 1;
                totalCardsElement.textContent = cards.length;
                cardsSeenElement.textContent = seenCards.size;
                cardsTotalElement.textContent = cards.length;
                
                // Mettre à jour la barre de progression
                progressBar.style.width = `${(seenCards.size / cards.length) * 100}%`;
                
                // Activer/désactiver les boutons
                prevBtn.disabled = cardHistory.length === 0;
                nextBtn.disabled = currentCardIndex === cards.length - 1;
                randomBtn.disabled = cards.length <= 1 || seenCards.size >= cards.length;
                
                // Définir la couleur de la carte en fonction des performances passées
                updateCardColor();
                
                // Vérifier si toutes les cartes ont été vues
                if (seenCards.size === cards.length) {
                    stopTimer(); // Arrêt définitif uniquement quand toutes les cartes sont vues
                }
            } else {
                frenchWord.textContent = "Aucune carte disponible";
                englishTranslation.textContent = "";
                englishTranslation.style.display = 'none';
                isTranslationVisible = false;
                
                // Mettre à jour l'information sur les cartes
                currentCardElement.textContent = "0";
                totalCardsElement.textContent = "0";
                cardsSeenElement.textContent = "0";
                cardsTotalElement.textContent = "0";
                
                // Mettre à jour la barre de progression
                progressBar.style.width = "0%";
                
                // Désactiver les boutons
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                randomBtn.disabled = true;
            }
        }
        
        // Fonction pour mettre à jour la couleur de la carte en fonction des performances passées
        function updateCardColor() {
            const cardKey = `${currentChapter}-${currentCardIndex}`;
            
            if (cardPerformance[cardKey]) {
                const performance = cardPerformance[cardKey];
                const successRate = performance.successes / performance.attempts;
                
                // Couleur allant du rouge (0% correct) au vert (100% correct)
                const r = Math.round(231 - (successRate * 231)); // 231 pour e74c3c (rouge)
                const g = Math.round(46 + (successRate * 140)); // 46 à 186 pour aller de e74c3c (rouge) à 2ecc71 (vert)
                const b = Math.round(60 - (successRate * 50)); // 60 à 10 pour e74c3c (rouge) à 2ecc71 (vert)
                
                card.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                
                // Ajuster la couleur du texte pour un meilleur contraste
                if (successRate > 0.5) {
                    frenchWord.style.color = "#333"; // Texte foncé sur fond clair
                } else {
                    frenchWord.style.color = "#fff"; // Texte clair sur fond foncé
                }
            } else {
                // Réinitialiser aux couleurs par défaut si pas d'historique
                card.style.backgroundColor = isDarkMode ? "#2c3e50" : "#fff";
                frenchWord.style.color = isDarkMode ? "#ffffff" : "#3498db";
            }
        }
        
        // Fonction pour générer le contenu en mode "raw"
        function generateRawContent() {
            const cards = vocabularyByChapter[currentChapter];
            let content = "";
            
            for (let i = 0; i < cards.length; i++) {
                content += `${cards[i].english}    ${cards[i].french}\n\n`;
            }
            
            rawContent.textContent = content;
        }
        
        // Fonction pour basculer le mode sombre
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            themeToggle.textContent = isDarkMode ? "Mode Clair" : "Mode Sombre";
            themeToggle.classList.toggle('active', isDarkMode);
            
            // Mettre à jour la couleur de la carte en fonction des performances
            updateCardColor();
        }
        
        // Fonction pour basculer le mode raw
        function toggleRawMode() {
            isRawMode = !isRawMode;
            rawToggle.textContent = isRawMode ? "Mode Flash Cards" : "Mode Raw";
            rawToggle.classList.toggle('active', isRawMode);
            
            if (isRawMode) {
                cardContainer.style.display = 'none';
                document.querySelector('.validation-container').style.display = 'none';
                rawContent.style.display = 'block';
                generateRawContent();
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                randomBtn.disabled = true;
            } else {
                cardContainer.style.display = 'block';
                document.querySelector('.validation-container').style.display = 'flex';
                rawContent.style.display = 'none';
                updateCard(); // Remet à jour les boutons de navigation
            }
        }
        
        // Fonction pour sélectionner une carte aléatoire non vue
        function selectRandomCard() {
            const cards = vocabularyByChapter[currentChapter];
            
            // Si toutes les cartes ont été vues, réinitialiser
            if (seenCards.size >= cards.length) {
                seenCards.clear();
                initializeRemainingCards();
            }
            
            // Si la liste des cartes restantes est vide, la réinitialiser
            if (remainingCards.length === 0) {
                initializeRemainingCards();
            }
            
            // Prendre une carte aléatoire de la liste des cartes restantes
            const randomIndex = Math.floor(Math.random() * remainingCards.length);
            const selectedCardIndex = remainingCards[randomIndex];
            
            // Retirer la carte de la liste des cartes restantes
            remainingCards.splice(randomIndex, 1);
            
            return selectedCardIndex;
        }
        
        // Initialiser la liste des cartes restantes (non vues)
        function initializeRemainingCards() {
            const cards = vocabularyByChapter[currentChapter];
            remainingCards = [];
            
            for (let i = 0; i < cards.length; i++) {
                if (!seenCards.has(i)) {
                    remainingCards.push(i);
                }
            }
        }
        
        // Fonction pour changer de chapitre
        function changeChapter(chapter) {
            // Mettre en pause le chronomètre sans vérifier le meilleur temps
            pauseTimer();
            
            // Sauvegarder le score actuel et réinitialiser
            updateBestScore();
            currentScore = 0;
            currentScoreElement.textContent = currentScore;
            
            currentChapter = chapter;
            currentCardIndex = 0;
            seenCards.clear();
            remainingCards = [];
            cardHistory = []; // Réinitialiser l'historique des cartes
            
            // Mettre à jour les boutons de chapitre
            chapterButtons.forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.chapter) === currentChapter);
            });
            
            // Réinitialiser et démarrer le chronomètre
            resetTimer();
            startTimer();
            
            // Afficher le meilleur score pour ce chapitre
            updateBestScoreDisplay();
            
            // Afficher le meilleur temps pour ce chapitre
            updateBestTimeDisplay();
            
            // Initialiser les cartes restantes
            initializeRemainingCards();
            
            if (isRawMode) {
                generateRawContent();
            } else {
                updateCard();
            }
        }
        
        // Fonctions pour le chronomètre
        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
            isTimerActive = true;
        }
        
        function pauseTimer() {
            if (isTimerActive) {
                clearInterval(timerInterval);
                isTimerActive = false;
            }
        }
        
        function stopTimer() {
            clearInterval(timerInterval);
            isTimerActive = false;
            
            // On vérifie uniquement le meilleur temps lorsqu'on arrête définitivement le chrono
            checkAndUpdateBestTime();
        }
        
        function resetTimer() {
            clearInterval(timerInterval);
            timerElement.textContent = "00:00";
            startTime = new Date();
        }
        
        function updateTimer() {
            const now = new Date();
            const elapsedTime = Math.floor((now - startTime) / 1000); // en secondes
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            
            timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function checkAndUpdateBestTime() {
            if (seenCards.size === 0) return; // Ne pas enregistrer si aucune carte n'a été vue
            
            const now = new Date();
            const elapsedTime = Math.floor((now - startTime) / 1000); // en secondes
            
            // Si c'est le premier temps pour ce chapitre ou si c'est meilleur que le précédent
            if (!bestTimes[currentChapter] || elapsedTime < bestTimes[currentChapter]) {
                bestTimes[currentChapter] = elapsedTime;
                updateBestTimeDisplay();
            }
        }
        
        function updateBestTimeDisplay() {
            if (bestTimes[currentChapter]) {
                const minutes = Math.floor(bestTimes[currentChapter] / 60);
                const seconds = bestTimes[currentChapter] % 60;
                bestTimeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                bestTimeElement.textContent = "-";
            }
        }
        
        // Fonction pour calculer la similarité entre deux chaînes
        function similarity(s1, s2) {
            s1 = s1.toLowerCase().trim();
            s2 = s2.toLowerCase().trim();
            
            // Si les deux chaînes sont vides, elles sont identiques
            if (s1 === s2) return 1.0;
            if (s1.length === 0 || s2.length === 0) return 0.0;
            
            // Calcul de la distance de Levenshtein
            const matrix = [];
            
            // Initialisation de la matrice
            for (let i = 0; i <= s1.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= s2.length; j++) {
                matrix[0][j] = j;
            }
            
            // Remplissage de la matrice
            for (let i = 1; i <= s1.length; i++) {
                for (let j = 1; j <= s2.length; j++) {
                    const cost = s1.charAt(i - 1) === s2.charAt(j - 1) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // suppression
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }
            
            // La distance est le dernier élément calculé dans la matrice
            const distance = matrix[s1.length][s2.length];
            
            // Calcul de la similarité (1 - distance normalisée)
            const maxLength = Math.max(s1.length, s2.length);
            return 1 - distance / maxLength;
        }
        
        // Fonction pour valider la traduction entrée par l'utilisateur
        function validateTranslation() {
            const userTranslation = translationInput.value.trim();
            
            if (userTranslation === "") {
                validationResult.textContent = "Veuillez entrer une traduction";
                validationResult.className = "validation-result";
                return;
            }
            const correctTranslation = vocabularyByChapter[currentChapter][currentCardIndex].english;
            const similarityScore = similarity(userTranslation, correctTranslation);
            
            // Ajouter cette tentative à l'historique des performances
            const cardKey = `${currentChapter}-${currentCardIndex}`;
            if (!cardPerformance[cardKey]) {
                cardPerformance[cardKey] = { attempts: 0, successes: 0 };
            }
            
            cardPerformance[cardKey].attempts++;
            
            // Si la similarité est supérieure à 80%, considérer comme correct
            if (similarityScore >= 0.8) {
                validationResult.textContent = "Correct!";
                validationResult.className = "validation-result correct";
                
                // Incrémenter le compteur de succès
                cardPerformance[cardKey].successes++;
                
                // Incrémenter le score actuel
                currentScore++;
                currentScoreElement.textContent = currentScore;
            } else {
                validationResult.textContent = `Incorrect. La réponse correcte est: ${correctTranslation}`;
                validationResult.className = "validation-result incorrect";
                
                // Afficher la traduction correcte
                englishTranslation.style.display = 'block';
                isTranslationVisible = true;
            }
            
            // Mettre à jour la couleur de la carte en fonction des performances
            updateCardColor();
        }
        
        // Fonction pour mettre à jour le meilleur score
        function updateBestScore() {
            if (currentScore > 0) {
                if (!bestScores[currentChapter] || currentScore > bestScores[currentChapter]) {
                    bestScores[currentChapter] = currentScore;
                }
            }
        }
        
        // Fonction pour afficher le meilleur score
        function updateBestScoreDisplay() {
            if (bestScores[currentChapter]) {
                bestScoreElement.textContent = bestScores[currentChapter];
            } else {
                bestScoreElement.textContent = "0";
            }
        }
        
        // Initialisation
        function init() {
            initializeRemainingCards();
            updateCard();
            startTimer();
            
            // Événement pour afficher/masquer la traduction
            card.addEventListener('click', () => {
                englishTranslation.style.display = isTranslationVisible ? 'none' : 'block';
                isTranslationVisible = !isTranslationVisible;
            });
            
            // Événement pour le bouton de validation
            validateBtn.addEventListener('click', validateTranslation);
            
            // Événement pour valider avec la touche Entrée
            translationInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    validateTranslation();
                }
            });
            
            // Événements pour les boutons de navigation
            prevBtn.addEventListener('click', () => {
                if (cardHistory.length > 0) {
                    // Prendre le dernier élément de l'historique
                    currentCardIndex = cardHistory.pop();
                    updateCard();
                }
            });
            
            nextBtn.addEventListener('click', () => {
                const cards = vocabularyByChapter[currentChapter];
                if (currentCardIndex < cards.length - 1) {
                    // Ajouter l'index actuel à l'historique avant de passer au suivant
                    cardHistory.push(currentCardIndex);
                    currentCardIndex++;
                    updateCard();
                }
            });
            
            randomBtn.addEventListener('click', () => {
                const cards = vocabularyByChapter[currentChapter];
                if (cards.length > 1 && seenCards.size < cards.length) {
                    // Ajouter l'index actuel à l'historique avant de passer à une carte aléatoire
                    cardHistory.push(currentCardIndex);
                    currentCardIndex = selectRandomCard();
                    updateCard();
                }
            });
            
            // Événements pour les boutons de chapitre
            chapterButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    changeChapter(parseInt(btn.dataset.chapter));
                });
            });
            
            // Événement pour le bouton du thème sombre/clair
            themeToggle.addEventListener('click', toggleDarkMode);
            
            // Événement pour le bouton du mode raw
            rawToggle.addEventListener('click', toggleRawMode);
            
            // Initialiser l'affichage du meilleur score
            updateBestScoreDisplay();
        }
        
        // Démarrer l'application
        init();
    </script>
</body>
</html>
