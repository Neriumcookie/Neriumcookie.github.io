<!DOCTYPE html>
<html lang="fr">
<head>
    <link rel="manifest" href="/site.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards Fran√ßais-Anglais</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --text-color: #333;
            --card-bg: #fff;
            --card-shadow: rgba(0, 0, 0, 0.1);
            --body-bg: #f5f7fa;
            --translation-color: #2ecc71;
            --subtitle-color: #666;
            --info-color: #666;
            --button-bg: #e0e0e0;
            --button-text: #333;
            --progress-bg: #e0e0e0;
            --incorrect-color: #e74c3c;
            --correct-color: #2ecc71;
            --save-button-bg: #f39c12;
            --load-button-bg: #9b59b6;
        }
        
        body.dark-mode {
            --primary-color: #ffffff;
            --secondary-color: #3498db;
            --text-color: #000000;
            --card-bg: #2c3e50;
            --card-shadow: rgba(0, 0, 0, 0.3);
            --body-bg: #1a1a1a;
            --translation-color: #3498db;
            --subtitle-color: #bbb;
            --info-color: #bbb;
            --button-bg: #34495e;
            --button-text: #fff;
            --progress-bg: #34495e;
            --incorrect-color: #e74c3c;
            --correct-color: #2ecc71;
            --save-button-bg: #d35400;
            --load-button-bg: #8e44ad;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--body-bg);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        
        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: var(--subtitle-color);
            text-align: center;
            margin-bottom: 30px;
        }
        
        .container {
            width: 100%;
            max-width: 600px;
        }
        
        .chapters {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .chapter-btn {
            padding: 8px 15px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .chapter-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .mode-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .mode-btn {
            padding: 8px 15px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .mode-btn.active {
            background-color: var(--primary-color);
            color: white;
        }
        
        .progress-container {
            width: 100%;
            height: 10px;
            background-color: var(--progress-bg);
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary-color);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        
        .card-container {
            height: 300px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .card {
            width: 100%;
            height: 100%;
            cursor: pointer;
            box-shadow: 0 10px 25px var(--card-shadow);
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--card-bg);
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .card-content {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .english-translation {
            color: var(--translation-color);
            font-size: 2rem;
            font-weight: bold;
            display: none;
        }
        
        .success-rate {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.9rem;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 3px 8px;
            border-radius: 10px;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .save-load-controls {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-top: 15px;
            gap: 10px;
        }
        
        .save-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--save-button-bg);
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .load-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--load-button-bg);
            color: white;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .save-btn:hover, .load-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        .save-input, .load-input {
            display: none;
        }
        
        .info {
            text-align: center;
            margin-top: 20px;
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        .timer-container {
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .stats-container {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        .raw-content {
            background-color: var(--card-bg);
            color: var(--text-color);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            width: 100%;
            height: 300px;
            overflow-y: auto;
            display: none;
            white-space: pre-line;
            box-shadow: 0 10px 25px var(--card-shadow);
            text-align: left;
            font-size: 1rem;
            line-height: 1.6;
        }
        
        .validation-container {
            width: 100%;
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .input-group {
            display: flex;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .translation-input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--button-bg);
            border-radius: 5px 0 0 5px;
            font-size: 1rem;
            background-color: var(--card-bg);
            color: var(--text-color);
        }
        
        .validate-btn {
            padding: 10px 15px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
            font-weight: 600;
        }
        
        .validation-result {
            margin-top: 5px;
            font-weight: bold;
            height: 20px;
        }
        
        .correct {
            color: var(--correct-color);
        }
        
        .incorrect {
            color: var(--incorrect-color);
        }
        
        .scores-container {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 10px;
        }
        
        .score-item {
            font-size: 0.9rem;
            color: var(--info-color);
        }
        
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        @media (max-width: 600px) {
            .card-content {
                font-size: 1.5rem;
            }
            
            .english-translation {
                font-size: 1.2rem;
            }
            
            .btn, .save-btn, .load-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            .translation-input {
                border-radius: 5px;
                margin-bottom: 5px;
            }
            
            .validate-btn {
                border-radius: 5px;
                width: 100%;
            }
            
            .save-load-controls {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Flash Cards Fran√ßais-Anglais</h1>
        <p class="subtitle">Traduisez le mot ou cliquez sur la carte pour voir la traduction</p>
        
        <div class="mode-controls">
            <button class="mode-btn" id="theme-toggle">Mode Sombre</button>
            <button class="mode-btn" id="raw-toggle">Mode Raw</button>
        </div>
        
        <div class="chapters">
            <button class="chapter-btn active" data-chapter="1">Democracy</button>
            <button class="chapter-btn" data-chapter="2">Genetics</button>
            <button class="chapter-btn" data-chapter="3">Immigration</button>
            <button class="chapter-btn" data-chapter="4">International tensions</button>
            <button class="chapter-btn" data-chapter="5">Unemployment</button>
        </div>
        
        <div class="timer-container">
            <div id="timer">00:00</div>
        </div>
        
        <div class="progress-container">
            <div class="progress-bar" style="width: 0%"></div>
        </div>
        
        <div class="card-container">
            <div class="card">
                <div class="card-content">
                    <div class="french-word"></div>
                    <div class="english-translation"></div>
                </div>
                <div class="success-rate" id="success-rate"></div>
            </div>
        </div>
        
        <div class="validation-container">
            <div class="input-group">
                <input type="text" class="translation-input" id="translation-input" placeholder="Entrez la traduction en anglais">
                <button class="validate-btn" id="validate-btn">Valider</button>
            </div>
            <div class="validation-result" id="validation-result"></div>
            <div class="scores-container">
                <div class="score-item">Score: <span id="current-score">0</span></div>
                <div class="score-item">Meilleur score: <span id="best-score">0</span></div>
            </div>
        </div>
        
        <div class="raw-content" id="raw-content"></div>
        
        <div class="controls">
            <button class="btn" id="prev-btn">Pr√©c√©dent</button>
            <button class="btn" id="random-btn">Al√©atoire</button>
            <button class="btn" id="next-btn">Suivant</button>
        </div>
        
        <div class="save-load-controls">
            <button class="save-btn" id="save-btn">Sauvegarder</button>
            <input type="file" id="load-input" class="load-input" accept=".json">
            <button class="load-btn" id="load-btn">Charger</button>
        </div>
        
        <div class="info">
            <span id="current-card">0</span>/<span id="total-cards">0</span>
        </div>
        
        <div class="stats-container">
            <div>Meilleur temps: <span id="best-time">-</span></div>
            <div>Cartes vues: <span id="cards-seen">0</span>/<span id="cards-total">0</span></div>
        </div>
    </div>
    
    <div class="toast" id="toast-message"></div>
    
    <script>
        // Structure de donn√©es pour les mots par chapitre
        const vocabularyByChapter = {
            1: [
{ french: "monarchie", english: "monarchy" },
{ french: "monarque de droit divin", english: "a monarch by divine right" },

{
  "french": "retrait√©",
  "english": "a pensioner, an old age pensioner, a retiree (US)"
},
{
  "french": "retraite",
  "english": "retirement"
},
{
  "french": "partir en pr√©-retraite",
  "english": "to take early retirement"
},
{
  "french": "√¢ge de la retraite",
  "english": "retirement age"
}]};
        
        // Variables d'√©tat
        let currentChapter = 1;
        let currentCardIndex = 0;
        let isTranslationVisible = false;
        let seenCards = new Set();
        let cardHistory = [];
        let isDarkMode = false;
        let isRawMode = false;
        let currentScore = 0;
        let cardOrder = [];
        let bestScores = {};
        let cardPerformance = {};
        let startTime;
        let timerInterval;
        let bestTimes = {};
        let isTimerActive = true;
        
        // √âl√©ments DOM
        const elements = {
            chapterButtons: document.querySelectorAll('.chapter-btn'),
            card: document.querySelector('.card'),
            cardContainer: document.querySelector('.card-container'),
            rawContent: document.getElementById('raw-content'),
            frenchWord: document.querySelector('.french-word'),
            englishTranslation: document.querySelector('.english-translation'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            randomBtn: document.getElementById('random-btn'),
            progressBar: document.querySelector('.progress-bar'),
            currentCardElement: document.getElementById('current-card'),
            totalCardsElement: document.getElementById('total-cards'),
            timerElement: document.getElementById('timer'),
            bestTimeElement: document.getElementById('best-time'),
            cardsSeenElement: document.getElementById('cards-seen'),
            cardsTotalElement: document.getElementById('cards-total'),
            themeToggle: document.getElementById('theme-toggle'),
            rawToggle: document.getElementById('raw-toggle'),
            translationInput: document.getElementById('translation-input'),
            validateBtn: document.getElementById('validate-btn'),
            validationResult: document.getElementById('validation-result'),
            currentScoreElement: document.getElementById('current-score'),
            bestScoreElement: document.getElementById('best-score'),
            successRateElement: document.getElementById('success-rate'),
            saveBtn: document.getElementById('save-btn'),
            loadBtn: document.getElementById('load-btn'),
            loadInput: document.getElementById('load-input'),
            toastMessage: document.getElementById('toast-message')
        };
        
        // Fonction pour afficher un message toast
        function showToast(message, duration = 3000) {
            elements.toastMessage.textContent = message;
            elements.toastMessage.classList.add('show');
            
            setTimeout(() => {
                elements.toastMessage.classList.remove('show');
            }, duration);
        }
        
        // Fonction pour sauvegarder l'√©tat actuel
        function saveState() {
            const state = {
                currentChapter,
                seenCards: Array.from(seenCards),
                cardPerformance,
                bestScores,
                bestTimes,
                isDarkMode,
                currentScore
            };
            
            // Convertir en JSON
            const stateJSON = JSON.stringify(state);
            
            // Cr√©er un objet Blob
            const blob = new Blob([stateJSON], { type: 'application/json' });
            
            // Cr√©er une URL pour le Blob
            const url = URL.createObjectURL(blob);
            
            // Cr√©er un √©l√©ment de lien
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcards_save_${new Date().toISOString().slice(0, 10)}.json`;
            
            // Ajouter le lien au document et cliquer dessus
            document.body.appendChild(a);
            a.click();
            
            // Nettoyer
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showToast('Sauvegarde r√©ussie!');
        }
        
        // Fonction pour charger un √©tat sauvegard√©
        function loadState(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const state = JSON.parse(e.target.result);
                    
                    // Restaurer l'√©tat
                    currentChapter = state.currentChapter || 1;
                    seenCards = new Set(state.seenCards || []);
                    cardPerformance = state.cardPerformance || {};
                    bestScores = state.bestScores || {};
                    bestTimes = state.bestTimes || {};
                    currentScore = state.currentScore || 0;
                    
                    // Restaurer le th√®me
                    isDarkMode = state.isDarkMode || false;
                    document.body.classList.toggle('dark-mode', isDarkMode);
                    elements.themeToggle.textContent = isDarkMode ? "Mode Clair" : "Mode Sombre";
                    elements.themeToggle.classList.toggle('active', isDarkMode);
                    
                    // Recharger le chapitre courant
                    currentCardIndex = 0;
                    cardHistory = [];
                    
                    elements.chapterButtons.forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.chapter) === currentChapter);
                    });
                    
                    // Mettre √† jour l'affichage
                    elements.currentScoreElement.textContent = currentScore;
                    updateBestScoreDisplay();
                    updateBestTimeDisplay();
                    resetTimer();
                    startTimer();
                    
                    if (isRawMode) {
                        generateRawContent();
                    } else {
                        updateCard();
                    }
                    
                    showToast('Chargement r√©ussi!');
                } catch (error) {
                    console.error('Erreur lors du chargement:', error);
                    showToast('Erreur lors du chargement du fichier');
                }
                
                // R√©initialiser l'input file pour permettre le rechargement du m√™me fichier
                elements.loadInput.value = '';
            };
            
            reader.readAsText(file);
        }
        
        // Fonction pour calculer et trier les cartes selon leur taux de succ√®s
        // Fonction pour calculer et trier les cartes selon leur taux de succ√®s
function getSortedCardsByPerformance() {
    const cards = vocabularyByChapter[currentChapter];
    if (!cards || cards.length === 0) return [];
    
    // Cr√©er un tableau d'objets contenant l'index et le taux de succ√®s
    const cardsWithRates = cards.map((_, index) => {
        const cardKey = `${currentChapter}-${index}`;
        const perf = cardPerformance[cardKey];
        
        // Valeurs par d√©faut pour les cartes jamais vues
        let successRate = -1;  // -1 pour les cartes jamais vues
        let isCardSeen = seenCards.has(index);
        
        if (perf) {
            successRate = perf.successes / perf.attempts;
            isCardSeen = true;
        }
        
        return { index, successRate, isCardSeen };
    });
    
    // Trier les cartes:
    // 1. D'abord les cartes vues avec le plus faible taux de succ√®s
    // 2. Ensuite les cartes jamais vues
    // 3. Enfin les cartes avec 100% de succ√®s
    cardsWithRates.sort((a, b) => {
        // Priorit√© aux cartes jamais vues vs cartes avec 100% de succ√®s
        if (a.successRate === -1 && b.successRate === 1) return -1;
        if (a.successRate === 1 && b.successRate === -1) return 1;
        
        // Si les deux sont jamais vues ou les deux ont le m√™me score, ordre al√©atoire
        if (a.successRate === b.successRate) {
            return Math.random() - 0.5;
        }
        
        // Cartes jamais vues ont priorit√© sur cartes d√©j√† vues
        if (a.successRate === -1) return -1;
        if (b.successRate === -1) return 1;
        
        // Sinon, trier par taux de succ√®s (ascendant)
        return a.successRate - b.successRate;
    });
    
    // Retourner seulement les indices
    return cardsWithRates.map(card => card.index);
}
        
        // Fonction pour mettre √† jour la carte
        function updateCard() {
                const cards = vocabularyByChapter[currentChapter];
                if (!cards || cards.length === 0) return showNoCardsMessage();
            
                // Utiliser cardOrder pour choisir la carte
                const realIndex = cardOrder[currentCardIndex];
                const cardData = cards[realIndex];
            
                elements.frenchWord.textContent        = cardData.french;
                elements.englishTranslation.textContent = cardData.english;
            
                // Marquer la carte comme vue
                seenCards.add(realIndex);
                
                elements.englishTranslation.style.display = 'none';
                isTranslationVisible = false;
                
                elements.translationInput.value = '';
                elements.validationResult.textContent = '';
                elements.validationResult.className = 'validation-result';
                
                // Mettre √† jour l'affichage des statistiques
                updateStatsDisplay();
                
                // Mettre √† jour la barre de progression
                elements.progressBar.style.width = `${(seenCards.size / cards.length) * 100}%`;
                
                // Activer/d√©sactiver les boutons
                elements.prevBtn.disabled = cardHistory.length === 0;
                elements.nextBtn.disabled = currentCardIndex === cards.length - 1;
                elements.randomBtn.disabled = cards.length <= 1 || seenCards.size >= cards.length;
                
                // Mettre √† jour la couleur de la carte et le taux de succ√®s
                updateCardColorAndSuccessRate(realIndex);
                
                // V√©rifier si toutes les cartes ont √©t√© vues
                if (seenCards.size === cards.length) {
                    stopTimer();
                }
            } else {
                showNoCardsMessage();
            }
        
        }
        
        // Fonction pour afficher un message quand il n'y a pas de cartes
        function showNoCardsMessage() {
            elements.frenchWord.textContent = "Aucune carte disponible";
            elements.englishTranslation.textContent = "";
            elements.englishTranslation.style.display = 'none';
            elements.currentCardElement.textContent = "0";
            elements.totalCardsElement.textContent = "0";
            elements.cardsSeenElement.textContent = "0";
            elements.cardsTotalElement.textContent = "0";
            elements.progressBar.style.width = "0%";
            elements.prevBtn.disabled = true;
            elements.nextBtn.disabled = true;
            elements.randomBtn.disabled = true;
            elements.successRateElement.textContent = "";
        }
        
        // Fonction pour mettre √† jour l'affichage des statistiques
        function updateStatsDisplay() {
            const cards = vocabularyByChapter[currentChapter];
            elements.currentCardElement.textContent = currentCardIndex + 1;
            elements.totalCardsElement.textContent = cards.length;
            elements.cardsSeenElement.textContent = seenCards.size;
            elements.cardsTotalElement.textContent = cards.length;
        }
        
        // Fonction pour mettre √† jour la couleur et le taux de succ√®s de la carte
        function updateCardColorAndSuccessRate() {
            const cardKey = `${currentChapter}-${currentCardIndex}`;
            
            if (cardPerformance[cardKey]) {
                const performance = cardPerformance[cardKey];
                const successRate = performance.successes / performance.attempts;
                const successPercentage = Math.round(successRate * 100);
                
                // Afficher le pourcentage de r√©ussite
                elements.successRateElement.textContent = `${successPercentage}%`;
                
                // Couleur allant du rouge (0% correct) au vert (100% correct)
                const r = Math.round(231 - (successRate * 231));
                const g = Math.round(46 + (successRate * 140));
                const b = Math.round(60 - (successRate * 50));
                
                elements.card.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                
                // Ajuster la couleur du texte pour un meilleur contraste
                elements.frenchWord.style.color = successRate > 0.5 ? "#333" : "#fff";
                
                // Ajuster la couleur du texte du taux de succ√®s
                elements.successRateElement.style.backgroundColor = successRate > 0.5 ? 
                    "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.7)";
                elements.successRateElement.style.color = successRate > 0.5 ? "#333" : "#fff";
            } else {
                // R√©initialiser aux couleurs par d√©faut si pas d'historique
                elements.card.style.backgroundColor = isDarkMode ? "#2c3e50" : "#fff";
                elements.frenchWord.style.color = isDarkMode ? "#ffffff" : "#3498db";
                elements.successRateElement.textContent = "";
            }
        }
        
        // Fonction pour g√©n√©rer le contenu en mode "raw"
        function generateRawContent() {
            const cards = vocabularyByChapter[currentChapter];
            let content = "";
            
            for (let i = 0; i < cards.length; i++) {
                content += `${cards[i].english}    ${cards[i].french}\n\n`;
            }
            
            elements.rawContent.textContent = content;
        }
        
        // Fonction pour basculer le mode sombre
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            elements.themeToggle.textContent = isDarkMode ? "Mode Clair" : "Mode Sombre";
            elements.themeToggle.classList.toggle('active', isDarkMode);
            updateCardColorAndSuccessRate();
        }
        
        // Fonction pour basculer le mode raw
       // Fonction pour basculer le mode raw
function toggleRawMode() {
    isRawMode = !isRawMode;
    elements.rawToggle.textContent = isRawMode ? "Mode Flash Cards" : "Mode Raw";
    elements.rawToggle.classList.toggle('active', isRawMode);
    
    // Si isRawMode est vrai, afficher le contenu brut et cacher la carte
    if (isRawMode) {
        elements.cardContainer.style.display = 'none';
        elements.rawContent.style.display = 'block';
        document.querySelector('.controls').style.display = 'none';
        elements.validationContainer.style.display = 'none';
        generateRawContent();
    } else {
        elements.cardContainer.style.display = 'block';
        elements.rawContent.style.display = 'none';
        document.querySelector('.controls').style.display = 'flex';
        elements.validationContainer.style.display = 'flex';
        updateCard();
    }
}

// Fonction pour mettre √† jour l'affichage du meilleur score
function updateBestScoreDisplay() {
    const bestScore = bestScores[currentChapter] || 0;
    elements.bestScoreElement.textContent = bestScore;
}

// Fonction pour d√©marrer le timer
function startTimer() {
    if (!isTimerActive) return;
    
    clearInterval(timerInterval);
    startTime = new Date();
    
    timerInterval = setInterval(() => {
        const now = new Date();
        const diff = new Date(now - startTime);
        const minutes = String(diff.getUTCMinutes()).padStart(2, '0');
        const seconds = String(diff.getUTCSeconds()).padStart(2, '0');
        
        elements.timerElement.textContent = `${minutes}:${seconds}`;
    }, 1000);
}

// Fonction pour arr√™ter le timer
function stopTimer() {
    clearInterval(timerInterval);
    
    // Sauvegarder le meilleur temps si c'est le cas
    if (isTimerActive) {
        const now = new Date();
        const totalTime = now - startTime;
        
        if (!bestTimes[currentChapter] || totalTime < bestTimes[currentChapter]) {
            bestTimes[currentChapter] = totalTime;
            updateBestTimeDisplay();
        }
    }
}

// Fonction pour r√©initialiser le timer
function resetTimer() {
    clearInterval(timerInterval);
    elements.timerElement.textContent = "00:00";
}

// Fonction pour mettre √† jour l'affichage du meilleur temps
function updateBestTimeDisplay() {
    const bestTime = bestTimes[currentChapter];
    
    if (bestTime) {
        const diff = new Date(bestTime);
        const minutes = String(diff.getUTCMinutes()).padStart(2, '0');
        const seconds = String(diff.getUTCSeconds()).padStart(2, '0');
        
        elements.bestTimeElement.textContent = `${minutes}:${seconds}`;
    } else {
        elements.bestTimeElement.textContent = "-";
    }
}

// Gestionnaires d'√©v√©nements
function initEventListeners() {
    // Changement de chapitre
    // Changement de chapitre
elements.chapterButtons.forEach(button => {
    button.addEventListener('click', () => {
        const chapter = parseInt(button.dataset.chapter);
        if (chapter === currentChapter) return;

        // bascule visuelle
        elements.chapterButtons.forEach(btn =>
            btn.classList.toggle('active', parseInt(btn.dataset.chapter) === chapter)
        );

        // changement de chapitre
        currentChapter   = chapter;
        currentCardIndex = 0;
        seenCards        = new Set();
        cardHistory      = [];

        // **tri initial ici une seule fois**
        cardOrder = getSortedCardsByPerformance();

        // timer, scores, UI
        resetTimer();
        startTimer();
        updateBestScoreDisplay();
        updateBestTimeDisplay();

        if (isRawMode) generateRawContent();
        else             updateCard();
    });
});
    
    // Retourner la carte
    elements.card.addEventListener('click', () => {
        isTranslationVisible = !isTranslationVisible;
        elements.englishTranslation.style.display = isTranslationVisible ? 'block' : 'none';
    });
    
    // Bouton pr√©c√©dent
    elements.prevBtn.addEventListener('click', () => {
        if (cardHistory.length > 0) {
            currentCardIndex = cardHistory.pop();
            updateCard();
        }
    });
    
    // Bouton suivant
    elements.nextBtn.addEventListener('click', () => {
        if (currentCardIndex < vocabularyByChapter[currentChapter].length - 1) {
            cardHistory.push(currentCardIndex);
            currentCardIndex++;
            updateCard();
        }
    });
    
    // Bouton al√©atoire
    // Bouton al√©atoire
// 1. Fix the random button to truly get the lowest score card
elements.randomBtn.addEventListener('click', () => {
    // choix al√©atoire dans l‚Äôordre d√©j√† d√©fini
    if (cardOrder.length <= 1) return;
    let nextIndex;
    do {
        nextIndex = Math.floor(Math.random() * cardOrder.length);
    } while (nextIndex === currentCardIndex);
    cardHistory.push(currentCardIndex);
    currentCardIndex = nextIndex;
    updateCard();
});
// 2. Modify the chapter button event listener to sort cards by performance
elements.chapterButtons.forEach(button => {
    button.addEventListener('click', () => {
        const chapter = parseInt(button.dataset.chapter);
        
        // Skip if clicking current chapter
        if (chapter === currentChapter) return;
        
        // Update active chapter button
        elements.chapterButtons.forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.chapter) === chapter);
        });
        
        // Change chapter
        currentChapter = chapter;
        cardHistory = [];
        seenCards = new Set();
        
        // Set current card to the one with lowest score
        const sortedIndices = getSortedCardsByPerformance();
        currentCardIndex = sortedIndices.length > 0 ? sortedIndices[0] : 0;
        
        // Reset timer and update UI
        resetTimer();
        startTimer();
        updateBestScoreDisplay();
        updateBestTimeDisplay();
        
        // Update display
        if (isRawMode) {
            generateRawContent();
        } else {
            updateCard();
        }
    });
});
    
    // Validation de la traduction
    elements.validateBtn.addEventListener('click', validateTranslation);
    elements.translationInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            validateTranslation();
        }
    });
    
    // Basculer le mode sombre
    elements.themeToggle.addEventListener('click', toggleDarkMode);
    
    // Basculer le mode raw
    elements.rawToggle.addEventListener('click', toggleRawMode);
    
    // Boutons de sauvegarde et chargement
    elements.saveBtn.addEventListener('click', saveState);
    elements.loadBtn.addEventListener('click', () => {
        elements.loadInput.click();
    });
    elements.loadInput.addEventListener('change', loadState);
}

// Fonction de validation de traduction
function validateTranslation() {
    const userInput = elements.translationInput.value.trim().toLowerCase();
    const cards = vocabularyByChapter[currentChapter];
    const correctAnswer = cards[currentCardIndex].english.toLowerCase();
    
    // V√©rifier la r√©ponse
    const isCorrect = userInput === correctAnswer;
    
    // Mettre √† jour la performance de la carte
    const cardKey = `${currentChapter}-${currentCardIndex}`;
    if (!cardPerformance[cardKey]) {
        cardPerformance[cardKey] = { attempts: 0, successes: 0 };
    }
    cardPerformance[cardKey].attempts++;
    
    if (isCorrect) {
        cardPerformance[cardKey].successes++;
        elements.validationResult.textContent = "Correct !";
        elements.validationResult.className = "validation-result correct";
        
        // Incr√©menter le score
        currentScore++;
        elements.currentScoreElement.textContent = currentScore;
        
        // Mettre √† jour le meilleur score
        if (!bestScores[currentChapter] || currentScore > bestScores[currentChapter]) {
            bestScores[currentChapter] = currentScore;
            elements.bestScoreElement.textContent = bestScores[currentChapter];
        }
    } else {
        elements.validationResult.textContent = `Incorrect. La r√©ponse √©tait : ${cards[currentCardIndex].english}`;
        elements.validationResult.className = "validation-result incorrect";
    }
    
    // Mettre √† jour la couleur de la carte
    updateCardColorAndSuccessRate();
    
    // Passer automatiquement √† la carte suivante apr√®s quelques secondes si la r√©ponse est correcte
    if (isCorrect && currentCardIndex < cards.length - 1) {
        setTimeout(() => {
            cardHistory.push(currentCardIndex);
            currentCardIndex++;
            updateCard();
        }, 1500);
    }
}

// Initialisation
function init() {
    // Charger les donn√©es depuis le localStorage
    const savedData = localStorage.getItem('flashcardsData');
    if (savedData) {
        try {
            const data = JSON.parse(savedData);
            seenCards = new Set(data.seenCards || []);
            cardPerformance = data.cardPerformance || {};
            bestScores = data.bestScores || {};
            bestTimes = data.bestTimes || {};
            isDarkMode = data.isDarkMode || false;
            
            // Appliquer le mode sombre si n√©cessaire
            document.body.classList.toggle('dark-mode', isDarkMode);
            elements.themeToggle.textContent = isDarkMode ? "Mode Clair" : "Mode Sombre";
            elements.themeToggle.classList.toggle('active', isDarkMode);
        } catch (e) {
            console.error("Erreur lors du chargement des donn√©es:", e);
        }
    }
    
    // Initialiser les gestionnaires d'√©v√©nements
    initEventListeners();
    
    // Initialiser l'affichage
    updateBestScoreDisplay();
    updateBestTimeDisplay();
    
    // D√©marrer le timer
    startTimer();
    
    // Afficher la premi√®re carte
    if (isRawMode) {
        generateRawContent();
    } else {
        updateCard();
    }
    
    // Sauvegarder les donn√©es avant de quitter
    window.addEventListener('beforeunload', () => {
        localStorage.setItem('flashcardsData', JSON.stringify({
            seenCards: Array.from(seenCards),
            cardPerformance,
            bestScores,
            bestTimes,
            isDarkMode
        }));
    });
}

// Lancer l'initialisation
init();
</script>
</body>
</html>
